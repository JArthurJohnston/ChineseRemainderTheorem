'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 3 December 2013 at 9:12:17 pm'!Object subclass: #ChineseRemainderCube	instanceVariableNames: 'coordSet primeSet primeProduct fulcrum cube listBySolution listByX list ByY listByZ'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 11:53'!coordSet	^coordSet! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 12:14'!coordSet: anArray	1 to: anArray size do: [ :i | self coordSet at: i put: (anArray at: i). ].! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 15:43'!cube	^cube.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 16:01'!fillCubeAndList	list := SortedCollection new.	1 to: (self primeSet at: 1) do: [ :x | 		1 to: (self primeSet at: 2) do: [ :y | 			1 to: (self primeSet at: 3) do: [ :z | 				| solution |				solution := self solutionFor: x for: y for: z.				cube					atX: x					atY: y					atZ: z					put: solution.				list add: solution -> (Array with: x with: y with: z). ]. ]. ].	^ listBySolution.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 15:40'!firstFiveSolutions	| first answers |	first := self fulcrum.	[ first > self primeProduct. ] whileTrue: [ first := first - self primeProduct. ].	answers := Array new: 5.	answers at: 1 put: first.	1 to: 4 do: [ :i | answers at: i + 1 put: first + (self primeProduct * i). ].	^ answers.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 15:42'!firstNSolutionsN: aNumber	| first answers |	first := self fulcrum.	[ first > self primeProduct. ] whileTrue: [ first := first - self primeProduct. ].	answers := Array new: aNumber.	answers at: 1 put: first.	1 to: aNumber - 1 do: [ :i | answers at: i + 1 put: first + (self primeProduct * i). ].	^ answers.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 12/1/2013 19:27'!firstSolution	| first |	first := self fulcrum.	(self coordSet at: 1) + (self coordSet at: 2) + (self coordSet at: 3) = 0		ifTrue: [ ^ 0. ].	[ first > self primeProduct. ] whileTrue: [ first := first - self primeProduct. ].	^ first.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/3/2013 12:44'!fulcrum	^ fulcrum ifNil: [ self setUpFulcrum. ].! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 11:58'!initialize	coordSet := Array new: 3.	primeSet := Array new: 3.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 16:02'!list	^list  .! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 12:02'!primeProduct	^primeProduct  ifNil: [ primeProduct := primeSet product].	! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 12:03'!primeProduct: aNumber	primeProduct := aNumber .	! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 11:54'!primeSet	^primeSet.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:14'!primeSet: anArray	anArray isSetWisePrime		ifFalse: [ ^ self. ].	1 to: anArray size do: [ :i | self primeSet at: i put: (anArray at: i). ].	cube := ThreeDimArray newWith: anArray first with: anArray second with: anArray third.	self primeProduct: anArray product.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/3/2013 12:44'!setUpFulcrum	^ fulcrum := (self solveForGroup: 1) + (self solveForGroup: 2) + (self solveForGroup: 3).! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 13:13'!solutionDisplayString	^ 'Any positive integer ' , self fulcrum asString , ' +- ' , self primeSet product asString.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 08:50'!solutionFor: xNum for: yNum for: zNum	self coordSet: (Array with: xNum with: yNum with: zNum).	self setUpFulcrum.	^ self firstSolution.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 12/1/2013 18:53'!solveForGroup: aNumber	| product count temp |	aNumber > 3		ifTrue: [ ^ self. ].	product := (self primeSet copyWithout: (self primeSet at: aNumber)) product.	temp := product.	count := 1.	[ temp % (self primeSet at: aNumber) = ((self coordSet at: aNumber) % (self primeSet at: aNumber)). ]		whileFalse: [ 			temp := product * count.			count := count + 1. ].	^ temp.! !